<!--
  Generated by AI-Powered README Generator
  Repository: https://github.com/WomB0ComB0/cdn
  Generated: 2025-11-19T03:08:18.241Z
  Format: md
  Style: comprehensive
-->

# üöÄ CDN Infrastructure: A Scalable & Robust Content Delivery Solution

A production-ready, Go-centric CDN infrastructure using Cloudflare R2, Workers, and Traefik as an API gateway, designed for high-performance and scalable content delivery.

[![GitHub Workflow Status (deploy)](https://img.shields.io/github/actions/workflow/status/WomB0ComB0/cdn/deploy.yml?branch=main&label=deploy&logo=github)](https://github.com/WomB0ComB0/cdn/actions/workflows/deploy.yml)
[![GitHub Workflow Status (upload assets)](https://img.shields.io/github/actions/workflow/status/WomB0ComB0/cdn/upload-assets.yml?branch=main&label=upload%20assets&logo=github)](https://github.com/WomB0ComB0/cdn/actions/workflows/upload-assets.yml)
[![License](https://img.shields.io/badge/License-MIT-blue.svg)](LICENSE)
[![Version](https://img.shields.io/badge/version-v1.0.0-blue)](openapi.yaml)
[![Go](https://img.shields.io/badge/Go-1.21%2B-00ADD8.svg?logo=go)](https://go.dev/)
[![Cloudflare Workers](https://img.shields.io/badge/Cloudflare-Workers-orange.svg?logo=cloudflare)](https://workers.cloudflare.com/)
[![Docker](https://img.shields.io/badge/Docker-20.10%2B-blue.svg?logo=docker)](https://www.docker.com/)

---

## üß≠ Table of Contents

-   [üöÄ CDN Infrastructure: A Scalable & Robust Content Delivery Solution](#-cdn-infrastructure-a-scalable--robust-content-delivery-solution)
-   [üß≠ Table of Contents](#-table-of-contents)
-   [‚ú® Overview](#-overview)
-   [üåü Feature Highlights](#-feature-highlights)
-   [üèõÔ∏è Architecture & Design](#Ô∏è-architecture--design)
    -   [High-Level Component Diagram](#high-level-component-diagram)
    -   [Core Components & Responsibilities](#core-components--responsibilities)
    -   [Technology Stack](#technology-stack)
-   [üõ†Ô∏è Getting Started](#Ô∏è-getting-started)
    -   [Prerequisites](#prerequisites)
    -   [Installation Steps](#installation-steps)
    -   [Configuration (Environment Variables)](#configuration-environment-variables)
    -   [Running the Application](#running-the-application)
-   [üí° Usage & Workflows](#-usage--workflows)
    -   [Uploading Assets](#uploading-assets)
    -   [Retrieving Assets](#retrieving-assets)
    -   [On-the-Fly Image Transformation](#on-the-fly-image-transformation)
    -   [Signed URLs for Secure Access](#signed-urls-for-secure-access)
    -   [Asset Manifest Generation & R2 Upload](#asset-manifest-generation--r2-upload)
    -   [Cloudflare Worker for Edge Caching & Routing](#cloudflare-worker-for-edge-caching--routing)
-   [üöß Limitations, Known Issues & Future Roadmap](#-limitations-known-issues--future-roadmap)
    -   [Current Limitations](#current-limitations)
    -   [Known Issues](#known-issues)
    -   [Future Roadmap](#future-roadmap)
-   [ü§ù Contributing & Development Guidelines](#-contributing--development-guidelines)
    -   [How to Contribute](#how-to-contribute)
    -   [Development Setup](#development-setup)
    -   [Branching & Pull Request Guidelines](#branching--pull-request-guidelines)
    -   [Code Style & Linting](#code-style--linting)
    -   [Testing](#testing)
-   [üìÑ License, Credits & Contact](#-license-credits--contact)
    -   [License](#license)
    -   [Acknowledgements](#acknowledgements)
    -   [Maintainer & Contact](#maintainer--contact)
-   [üìö Appendix](#-appendix)
    -   [Changelog](#changelog)
    -   [FAQ](#faq)
    -   [Troubleshooting](#troubleshooting)
    -   [API Reference](#api-reference)

---

## ‚ú® Overview

This project provides a robust, production-ready CDN infrastructure designed to efficiently serve static and dynamic content. It leverages a powerful combination of **Cloudflare R2** for cost-effective object storage, **Cloudflare Workers** for intelligent edge caching and routing, and **Traefik** as a dynamic API gateway. At its core, a **Go-based media service** acts as the origin for asset management, offering features like ETag handling, range requests, and secure signed URLs. Complementary services such as `imgproxy` for on-the-fly image transformations and `Hasura` for GraphQL data access further enhance its capabilities.

**Purpose & Goals:**
The primary goal of this application is to provide a highly scalable, performant, and secure content delivery solution that is easy to deploy and manage. It aims to offload media serving responsibilities from core application servers, reduce latency for end-users, and minimize infrastructure costs.

**Why it Matters / Problem it Solves:**
Traditional content delivery can be slow, expensive, and complex to manage. This infrastructure solves these problems by:
-   **Reducing Latency:** Utilizing Cloudflare's global edge network and Workers to cache content closer to users.
-   **Lowering Costs:** Cloudflare R2 offers egress-free storage, significantly cutting down operational expenses compared to other cloud providers.
-   **Enhancing Scalability:** Designed from the ground up to handle high traffic volumes and large content libraries without compromising performance.
-   **Improving Developer Experience:** Provides a clear API for asset management and integrated image processing, abstracting away complex CDN configurations.
-   **Boosting Security:** Incorporates signed URLs and robust API gateway security measures to protect content.

**Target Audience:**
This solution is ideal for:
-   **Web Developers & Startups:** Seeking a fast, affordable, and scalable way to serve static assets, images, and media files for their applications and websites.
-   **DevOps Engineers:** Looking for a Dockerized, cloud-native CDN solution with modern tooling and automation capabilities.
-   **Content-Heavy Applications:** Websites, blogs, e-commerce platforms, and media portals requiring efficient delivery of large volumes of diverse content.

[‚¨ÜÔ∏è Back to Top](#-table-of-contents)

---

## üåü Feature Highlights

This CDN infrastructure is packed with features to ensure optimal performance, security, and developer experience:

-   ‚úÖ **Scalable Object Storage with Cloudflare R2**:
    -   Leverages Cloudflare R2 for highly durable and cost-effective object storage with zero egress fees.
    -   Acts as the primary origin for all media assets.

-   üöÄ **Edge Caching & Intelligent Routing with Cloudflare Workers**:
    -   A dedicated Cloudflare Worker (`cdn-worker.js`) intercepts requests, caches content at the edge, and intelligently routes traffic.
    -   Reduces latency and origin load, improving content delivery speed globally.

-   üîí **Secure API Gateway with Traefik**:
    -   **Dynamic Routing**: Configures routes for various services (`go-media`, `node-core`, `hasura`, `imgproxy`) based on hostnames and path prefixes.
    -   **Automatic SSL/TLS**: Integrates with Cloudflare ACME resolver for automatic certificate management.
    -   **Middleware**: Applies CORS, compression, and security headers globally or per service.
    -   **Basic Auth**: Protects administrative dashboards (e.g., Traefik Dashboard).

-   ‚öôÔ∏è **Go-centric Media Service (`go-media`)**:
    -   **Asset Upload API**: Securely uploads files to Cloudflare R2 via a robust Go API (`/v1/media/upload`).
    -   **Asset Retrieval**: Serves content directly from R2, supporting `ETag` for conditional requests and `Range` headers for partial content delivery (e.g., video streaming).
    -   **Signed URLs**: Generates time-limited, signed URLs to provide secure, temporary access to private assets.
    -   **Health Checks**: Provides a `/health` endpoint for robust container orchestration.

-   üñºÔ∏è **On-the-Fly Image Transformation with `imgproxy`**:
    -   Integrates `imgproxy` for real-time image resizing, cropping, watermarking, and format conversion.
    -   Optimizes images for web delivery, improving page load times and user experience.
    -   Supports S3-compatible storage (Cloudflare R2) as a source.
    -   Automatically enforces and detects WebP for modern browser compatibility.

-   üì¶ **Docker & Docker Compose for Easy Deployment**:
    -   All services are containerized, ensuring consistent environments and simplified deployment.
    -   `docker-compose.yml` orchestrates all services, making local development and self-hosting straightforward.

-   üìú **Automated Asset Management Scripts**:
    -   `scripts/generate-asset-manifest.js`: Creates a manifest of all assets, useful for cache invalidation and tracking.
    -   `scripts/upload-to-r2.js`: Automates batch uploads of assets to R2 storage.

-   üîó **Integrations**:
    -   **Node.js Core Service (`node-core`)**: Example service demonstrating integration behind Traefik.
    -   **Hasura GraphQL Engine**: Provides a GraphQL API for data interaction, also exposed via Traefik.

-   CI/CD Workflows (`.github/workflows`):
    -   **`deploy.yml`**: Automates the deployment of services.
    -   **`upload-assets.yml`**: Facilitates automated asset uploads to the CDN.

<details>
<summary>üí° **Tip**: Click to expand for a detailed look at the core services.</summary>

### Deep Dive into Core Services:

*   **`traefik`**: The central traffic manager. It's the first point of contact for all incoming requests, routing them to the correct backend service and applying security policies. Its dynamic configuration abilities, especially with Docker labels, make it highly flexible.
*   **`go-media`**: This is your direct interface for managing media files in R2. It handles the initial upload, provides the means to retrieve files, and is responsible for generating secure signed URLs. Written in Go for high performance and low resource usage.
*   **`cloudflare-worker`**: Deployed globally across Cloudflare's edge network, this worker serves two main purposes: it acts as a very fast cache layer, reducing load on your origin, and it can perform custom routing logic or add/modify headers before requests hit `go-media` or `imgproxy`.
*   **`imgproxy`**: A highly optimized image processing service. It takes an image URL, applies specified transformations (resize, crop, convert format), and returns the optimized image. Crucially, it fetches source images directly from R2, meaning `go-media` doesn't have to proxy the image data.
*   **`hasura`**: While not directly part of the CDN function, it demonstrates how a GraphQL API can be exposed and managed through the same Traefik gateway, potentially serving metadata about your assets.
*   **`node-core`**: A placeholder for your main application's backend services, showcasing how they integrate seamlessly behind the Traefik gateway.

</details>

[‚¨ÜÔ∏è Back to Top](#-table-of-contents)

---

## üèõÔ∏è Architecture & Design

The CDN infrastructure is built on a microservices-oriented architecture, leveraging a combination of self-hosted services and serverless components from Cloudflare. This design ensures high availability, scalability, and flexibility.

### High-Level Component Diagram

This diagram illustrates the primary components and their interactions within the CDN ecosystem.

```mermaid
graph TD
    subgraph Client/User
        A[User Browser/Application]
    end

    subgraph Edge Network
        B[Cloudflare DNS] --> C(Cloudflare Worker - cdn.example.com)
        C -- Cache Hit --> A
        C -- Cache Miss / API Request --> TraefikGW(Traefik API Gateway)
    end

    subgraph Origin Services (Self-Hosted/Docker Compose)
        TraefikGW -- API Host/Path --> GM(Go Media Service - api.example.com/v1/media)
        TraefikGW -- API Host/Path --> NC(Node Core Service - api.example.com/v1/core)
        TraefikGW -- API Host/Path --> H(Hasura GraphQL - api.example.com/v1/links/graphql)
        TraefikGW -- Image Path --> IP(Imgproxy - cdn.example.com/img)
    end

    subgraph Object Storage
        GM -- Store/Retrieve --> R2(Cloudflare R2 Bucket)
        IP -- Retrieve Source --> R2
        C -- Fallback/Direct Fetch --> R2
    end

    subgraph Database (External)
        NC -- Read/Write --> DB(External Database)
        H -- Connect --> DB
    end

    A -- Request Content --> B
    style A fill:#e0f2f7,stroke:#333,stroke-width:2px
    style B fill:#fdf6e3,stroke:#333,stroke-width:2px
    style C fill:#d0e6f7,stroke:#333,stroke-width:2px
    style TraefikGW fill:#fff0d9,stroke:#333,stroke-width:2px
    style GM fill:#e0ffd0,stroke:#333,stroke-width:2px
    style NC fill:#ffe0d0,stroke:#333,stroke-width:2px
    style H fill:#d0dfff,stroke:#333,stroke-width:2px
    style IP fill:#ffd0ff,stroke:#333,stroke-width:2px
    style R2 fill:#d0f0ff,stroke:#333,stroke-width:2px
    style DB fill:#e0e0e0,stroke:#333,stroke-width:2px
```

### Core Components & Responsibilities

-   **Cloudflare DNS & Worker**:
    -   **DNS**: Manages domain resolution, directing traffic to Cloudflare's edge network.
    -   **Cloudflare Worker (`cdn-worker.js`)**: Acts as an intelligent edge proxy. It handles requests for static assets, serves cached content, and can perform custom routing logic (e.g., redirecting to `imgproxy` or `go-media` based on URL patterns). It's the first line of defense and optimization for content delivery.

-   **Traefik API Gateway (`traefik`)**:
    -   **Entry Point**: All API requests and requests for origin content pass through Traefik.
    -   **Dynamic Routing**: Uses Docker labels to automatically discover and route requests to backend services based on hostnames and path prefixes.
    -   **SSL Termination**: Handles HTTPS with automatic certificate provisioning via Cloudflare's ACME resolver.
    -   **Middleware**: Applies global or service-specific middlewares (CORS, compression, security headers, basic authentication).

-   **Go Media Service (`go-media`)**:
    -   **Asset Management Origin**: The primary service for interacting with Cloudflare R2.
    -   **Uploads**: Provides an API endpoint (`/v1/media/upload`) to securely upload files.
    -   **Retrieval**: Fetches assets from R2, handling HTTP headers like `ETag` for caching validation and `Range` for partial content requests.
    -   **Signed URLs**: Generates secure, time-limited URLs for controlled access to private assets.

-   **Imgproxy (`imgproxy`)**:
    -   **Image Transformation**: On-the-fly image processing (resizing, cropping, format conversion, quality optimization).
    -   **Source**: Configured to directly pull source images from the Cloudflare R2 bucket.
    -   **Integration**: Exposed via Traefik under a specific path (e.g., `/img`) and configured with security keys.

-   **Node Core Service (`node-core`)**:
    -   An example Node.js backend application service.
    -   Demonstrates how other microservices can coexist and be exposed securely via Traefik.

-   **Hasura GraphQL Engine (`hasura`)**:
    -   Provides a real-time GraphQL API over a PostgreSQL database.
    -   Example for how a third-party service can be integrated into the Traefik-managed API landscape.

-   **Cloudflare R2 Bucket**:
    -   **Object Storage**: The highly scalable, durable, and cost-effective storage solution for all media assets.
    -   **Zero Egress Fees**: A key differentiator, making it economical for high-traffic CDNs.

### Technology Stack

| Component            | Technology/Tool                                      | Description                                                                 |
| :------------------- | :--------------------------------------------------- | :-------------------------------------------------------------------------- |
| **API Gateway**      | Traefik (v2.10+)                                     | Reverse proxy, load balancer, SSL termination, and API gateway.             |
| **Object Storage**   | Cloudflare R2                                        | S3-compatible, egress-free object storage.                                  |
| **Edge Compute**     | Cloudflare Workers (`cdn-worker.js`)                 | Serverless JavaScript/TypeScript functions for edge logic and caching.      |
| **Media Service**    | Go (1.21+)                                           | High-performance backend for asset management, uploads, and signed URLs.    |
| **Image Processing** | imgproxy (v3.21+)                                    | On-the-fly image optimization and transformation.                           |
| **Core Services**    | Node.js (Express), Hasura GraphQL Engine             | Example backend service and GraphQL API layer.                              |
| **Orchestration**    | Docker, Docker Compose                               | Containerization and local multi-service orchestration.                     |
| **API Definition**   | OpenAPI 3.0.3 (`openapi.yaml`)                       | Standardized API documentation and definition for the media service.        |
| **CI/CD**            | GitHub Actions                                       | Automated workflows for deployment and asset uploads.                       |
| **Tooling**          | `wrangler` CLI (Cloudflare Workers), AWS S3 SDK (Go) | CLI for Cloudflare Workers, SDK for R2 interaction.                         |

[‚¨ÜÔ∏è Back to Top](#-table-of-contents)

---

## üõ†Ô∏è Getting Started

Follow these steps to set up and run the CDN infrastructure on your local machine or a server.

### Prerequisites

Ensure you have the following installed on your system:

-   **Docker**: v20.10+ (for containerization)
    -   [Install Docker](https://docs.docker.com/get-docker/)
-   **Docker Compose**: v3.8+ (for multi-container orchestration)
    -   Included with Docker Desktop or install separately.
-   **`wrangler` CLI**: v3.0+ (for managing Cloudflare Workers)
    -   `npm install -g wrangler` (Node.js/npm required)
-   **Cloudflare Account**: Necessary for R2 storage, Workers, and DNS.
-   **Domain Name**: A domain configured with Cloudflare DNS for Traefik and Worker routes.

### Installation Steps

1.  **Clone the Repository**:
    ```bash
    git clone https://github.com/WomB0ComB0/cdn.git
    cd cdn
    ```

2.  **Set up Environment Variables**:
    Copy the example environment file and fill in your Cloudflare and other credentials.

    ```bash
    cp .env.example .env
    ```

    <details>
    <summary>Click to view a breakdown of `.env` variables</summary>

    The `.env` file contains critical configuration for all services.
    **Cloudflare Credentials (for Traefik & R2)**:
    *   `CLOUDFLARE_EMAIL`: Email for your Cloudflare account (used by Traefik for ACME).
    *   `CLOUDFLARE_API_KEY`: Global API Key from your Cloudflare profile (for Traefik ACME).
    *   `CLOUDFLARE_ZONE_ID`: The Zone ID of your domain in Cloudflare (for `go-media` if DNS updates are needed, and `cloudflare-worker`).
    *   `CLOUDFLARE_API_TOKEN`: A Cloudflare API Token with appropriate permissions (e.g., Zone -> DNS -> Edit, Workers Script -> Edit).

    **R2 Bucket Credentials (for Go Media & Imgproxy)**:
    *   `R2_ACCOUNT_ID`: Your Cloudflare account ID.
    *   `R2_ACCESS_KEY_ID`: R2 Access Key ID (created in R2 dashboard).
    *   `R2_SECRET_ACCESS_KEY`: R2 Secret Access Key (created in R2 dashboard).
    *   `R2_BUCKET_NAME`: The name of your R2 bucket.
    *   `R2_ENDPOINT`: The public endpoint for your R2 bucket (e.g., `https://<ACCOUNT_ID>.r2.cloudflarestorage.com`).

    **Security & Service Specific**:
    *   `SIGNING_SECRET`: A strong, random secret key for generating and verifying signed URLs in `go-media`.
        *   üí° *Tip*: Use `openssl rand -base64 32` to generate a secure key.
    *   `TRAEFIK_DASHBOARD_AUTH`: Basic authentication credentials for the Traefik dashboard (e.g., `user:hashedpassword`).
        *   üí° *Tip*: Use `htpasswd -nb user password` to generate this string.
    *   `HASURA_DATABASE_URL`: Connection string for your PostgreSQL database used by Hasura.
    *   `HASURA_ADMIN_SECRET`: Admin secret for Hasura GraphQL engine (critical for security).
    *   `HASURA_JWT_SECRET`: JWT secret for Hasura authentication (if using JWT).
    *   `IMGPROXY_KEY`: A secret key for `imgproxy` URL signing.
    *   `IMGPROXY_SALT`: A secret salt for `imgproxy` URL signing.
        *   üí° *Tip*: Use `openssl rand -hex 32` for `IMGPROXY_KEY` and `IMGPROXY_SALT`.
    *   `DATABASE_URL`: Database connection string for the `node-core` service.

    **Domain Configuration**:
    Update the `Host()` rules in `docker-compose.yml` to reflect your actual domain(s) instead of `mikeodnis.dev`. For example:
    *   `traefik.http.routers.dashboard.rule=Host(\`traefik.yourdomain.com\`)`
    *   `traefik.http.routers.go-media.rule=Host(\`api.yourdomain.com\`) && PathPrefix(\`/v1/media\`)`
    *   `traefik.http.routers.imgproxy.rule=Host(\`cdn.yourdomain.com\`) && PathPrefix(\`/img\`)`

    </details>

3.  **Configure Cloudflare Worker**:
    Navigate to the `cloudflare-worker` directory and configure `wrangler.toml`.

    ```bash
    cd cloudflare-worker
    cp wrangler.toml.example wrangler.toml # If provided, otherwise ensure it matches your R2 bucket
    ```

    Edit `wrangler.toml` to link to your R2 bucket:
    ```toml
    # cloudflare-worker/wrangler.toml
    name = "cdn-worker"
    main = "cdn-worker.js"
    compatibility_date = "2023-11-21"

    [vars]
    # Set any environment variables your worker needs, e.g., for custom logic
    # MY_ENV_VAR = "some_value"

    [[r2_buckets]]
    binding = "R2_BUCKET" # This is the binding name you'll use in cdn-worker.js
    bucket_name = "<YOUR_R2_BUCKET_NAME>" # Replace with your R2_BUCKET_NAME from .env
    preview_bucket_name = "<YOUR_R2_BUCKET_NAME>-preview" # Optional, for preview deployments
    ```

    Ensure your Cloudflare DNS records point to Cloudflare for the domains you've configured (e.g., `api.yourdomain.com`, `cdn.yourdomain.com`, `traefik.yourdomain.com`). These should be `A` records proxied by Cloudflare.

### Running the Application

1.  **Deploy Cloudflare Worker**:
    From the `cloudflare-worker` directory, deploy your worker. This will make your edge caching and routing logic active.

    ```bash
    cd cloudflare-worker
    wrangler deploy
    ```
    Follow the prompts to authenticate with Cloudflare.

2.  **Start Docker Services**:
    From the root directory of the project, start all services using Docker Compose.

    ```bash
    cd .. # Back to project root
    docker compose up -d
    ```

    This command will:
    -   Build the `go-media` and `node-core` Docker images.
    -   Pull images for Traefik, Hasura, and Imgproxy.
    -   Start all services in detached mode.

    <details>
    <summary>üîç **Verify Services**: Check if all containers are running correctly.</summary>

    ```bash
    docker compose ps
    ```
    You should see `Up` status for all services: `cdn-traefik`, `cdn-go-media`, `cdn-node-core`, `cdn-hasura`, `cdn-imgproxy`.

    Check Traefik logs for any certificate provisioning issues:
    ```bash
    docker compose logs cdn-traefik
    ```
    Look for messages indicating successful certificate issuance from Cloudflare.
    </details>

### Running in Development vs. Production

The `docker-compose.yml` is generally suitable for both development and production, but with a few considerations:

-   **Development**:
    -   The Traefik dashboard is exposed on `8080`.
    -   Hasura console is disabled by default, but can be enabled for development by changing `HASURA_GRAPHQL_ENABLE_CONSOLE: "true"`.
    -   Live reloading for `go-media` or `node-core` is not configured by default but can be added via bind mounts and specific development tooling if needed.
    -   `openapi.yaml` can be used with tools like Swagger UI for API exploration.

-   **Production**:
    -   Ensure `TRAEFIK_DASHBOARD_AUTH` is strong and securely managed.
    -   Consider disabling the Traefik dashboard (`8080` port mapping) entirely or restricting access.
    -   Ensure `HASURA_GRAPHQL_ENABLE_CONSOLE: "false"` for security.
    -   Use a dedicated external database for Hasura and Node Core, not one managed by Docker Compose unless it's a persistent volume setup.
    -   Implement robust backup strategies for R2 and any databases.
    -   Monitor logs and health checks diligently.
    -   CI/CD pipelines (like the provided GitHub Actions) are essential for automated and consistent deployments.

[‚¨ÜÔ∏è Back to Top](#-table-of-contents)

---

## üí° Usage & Workflows

This section guides you through common use cases and demonstrates how to interact with the CDN infrastructure.

### Uploading Assets

Assets are uploaded to the `go-media` service, which then stores them in the Cloudflare R2 bucket. The OpenAPI specification defines the `/upload` endpoint.

**Endpoint**: `POST https://api.yourdomain.com/v1/media/upload`
**Content-Type**: `multipart/form-data`

<details>
<summary>Example: Uploading a file via cURL</summary>

```bash
# Replace 'api.yourdomain.com' with your API domain
# Replace 'path/to/your/image.jpg' with the actual file path
curl -X POST \
  https://api.yourdomain.com/v1/media/upload \
  -H 'Content-Type: multipart/form-data' \
  -F 'file=@path/to/your/image.jpg'
```

Upon successful upload, the API will return a JSON response similar to this:

```json
{
  "key": "images/your/image.jpg",
  "url": "https://cdn.yourdomain.com/images/your/image.jpg",
  "etag": "\"some-etag-hash\"",
  "size": 123456
}
```
The `key` is the unique identifier for the object in R2, and `url` is the public URL through your CDN.
</details>

### Retrieving Assets

Once uploaded, assets can be retrieved directly from the CDN endpoint configured by your Cloudflare Worker and Traefik.

**Public CDN URL Pattern**: `https://cdn.yourdomain.com/{asset_key}`

<details>
<summary>Example: Retrieving an image</summary>

Assuming an asset was uploaded with the key `images/example.png`:

```
https://cdn.yourdomain.com/images/example.png
```

You can use `curl` to verify retrieval and inspect headers:

```bash
curl -I https://cdn.yourdomain.com/images/example.png
```

Expected headers would include `ETag`, `Content-Length`, `Content-Type`, and caching headers from Cloudflare.
</details>

### On-the-Fly Image Transformation

The `imgproxy` service allows for dynamic image manipulation by crafting specific URLs. This is exposed via Traefik, typically under `/img`.

**Imgproxy URL Pattern**: `https://cdn.yourdomain.com/img/{signature}/{operations}/{source_url}`

The `source_url` should be the full R2 URL or a path imgproxy can access. With `IMGPROXY_ALLOWED_SOURCES=s3://${R2_BUCKET_NAME}`, `imgproxy` can directly access R2 assets.

**Example**: Resize an image to 300px width and convert to WebP.

Let's say your source image in R2 is `s3://your-r2-bucket-name/images/original.jpg`.
The `imgproxy` endpoint is `https://cdn.yourdomain.com/img`.

You'd construct a URL like this (simplified, without signature for brevity):

```
https://cdn.yourdomain.com/img/resize:fit:300:0/q:85/plain/s3://your-r2-bucket-name/images/original.jpg@webp
```

<details>
<summary>üí° **Important**: Imgproxy Signature Calculation</summary>

For production use, `imgproxy` URLs *must* be signed using `IMGPROXY_KEY` and `IMGPROXY_SALT` for security. The full URL structure is:

`https://cdn.yourdomain.com/img/<signature>/<operations>/<encoded_source_url>.<extension>`

You can find official `imgproxy` client libraries for various languages to generate these signed URLs easily:
-   [imgproxy-go](https://github.com/imgproxy/imgproxy-go)
-   [imgproxy-js](https://github.com/imgproxy/imgproxy-js)

Here's a conceptual example using the `imgproxy-go` library:

```go
package main

import (
	"fmt"
	"github.com/imgproxy/imgproxy-go"
	"log"
)

func main() {
	// These would come from your .env and be securely loaded
	key := "your_imgproxy_key_hex"
	salt := "your_imgproxy_salt_hex"
	baseUrl := "https://cdn.yourdomain.com/img" // Your imgproxy public endpoint

	signer := imgproxy.NewURLSignerFromHex(key, salt)

	// Your original R2 asset URL (imgproxy configured to read directly from S3-compatible R2)
	sourceURL := "s3://your-r2-bucket-name/assets/my_photo.jpg"

	urlBuilder := imgproxy.NewURLBuilder().
		SetBaseURL(baseUrl).
		SetURLSigner(signer).
		SetOptions(imgproxy.NewOptions().
			SetResize(imgproxy.ResizeFit, 300, 0, false). // Fit to 300px width
			SetQuality(80).                               // 80% quality
			SetFormat(imgproxy.FormatWebp),               // Convert to WebP
		)

	signedURL, err := urlBuilder.Build(sourceURL)
	if err != nil {
		log.Fatal(err)
	}

	fmt.Println("Signed Imgproxy URL:", signedURL)
	// Example output: https://cdn.yourdomain.com/img/Uq0x...zD_d/fit/300/0/80/webp/c2J...19M/my_photo.webp
}
```

This dynamically generated URL ensures that only authorized transformations can be requested.
</details>

### Signed URLs for Secure Access

For private or protected assets, the `go-media` service can generate time-limited, signed URLs. This allows temporary access without exposing the R2 bucket directly or requiring user authentication at the CDN level.

**Endpoint**: (Typically an internal API call or a separate public endpoint if you need users to request signed URLs)
The generation logic resides within the `go-media` service.

<details>
<summary>Code Example: Generating a Signed URL (within Go Media)</summary>

The `go-media` service has a `storage/r2.go` module that handles interaction with Cloudflare R2 and includes logic for pre-signing URLs.

```go
// storage/r2.go (simplified)
package storage

import (
	"context"
	"fmt"
	"github.com/aws/aws-sdk-go-v2/aws"
	"github.com/aws/aws-sdk-go-v2/service/s3"
	"time"
)

// R2Storage provides methods for interacting with Cloudflare R2
type R2Storage struct {
	client    *s3.Client
	presigner *s3.PresignClient
	bucket    string
}

// NewR2Storage initializes a new R2Storage client
func NewR2Storage(cfg aws.Config, bucketName string) *R2Storage {
	client := s3.NewFromConfig(cfg)
	return &R2Storage{
		client:    client,
		presigner: s3.NewPresignClient(client),
		bucket:    bucketName,
	}
}

// GenerateSignedURL generates a pre-signed URL for GET requests to an object
func (r *R2Storage) GenerateSignedURL(ctx context.Context, key string, expiration time.Duration) (string, error) {
	request, err := r.presigner.PresignGetObject(ctx,
		&s3.GetObjectInput{
			Bucket: aws.String(r.bucket),
			Key:    aws.String(key),
		},
		s3.WithPresignExpires(expiration),
	)
	if err != nil {
		return "", fmt.Errorf("failed to presign URL: %w", err)
	}
	return request.URL, nil
}
```

To use this, your `handlers/media.go` would expose an endpoint (e.g., `GET /v1/media/signed-url?key=private/document.pdf`) that calls `GenerateSignedURL`.

When a client receives this signed URL, they can access the private asset directly from R2 (or the Cloudflare Worker if it's configured to honor signed URLs) for the specified duration.

</details>

### Asset Manifest Generation & R2 Upload

The `scripts` directory contains utilities for batch operations.

1.  **Generate Asset Manifest**:
    The `generate-asset-manifest.js` script can crawl a local directory and create a JSON manifest of all files, including their paths and hashes. This is useful for deploying static sites or for advanced cache invalidation strategies.

    ```bash
    node scripts/generate-asset-manifest.js <path_to_assets_directory>
    ```

2.  **Upload Assets to R2**:
    The `upload-to-r2.js` script automates uploading local files to your R2 bucket. It's often used in CI/CD pipelines.

    ```bash
    # Ensure R2_ACCOUNT_ID, R2_ACCESS_KEY_ID, R2_SECRET_ACCESS_KEY, R2_BUCKET_NAME
    # are set as environment variables (e.g., from your .env file)
    node scripts/upload-to-r2.js <path_to_local_directory> <r2_prefix_path>
    ```
    Example: `node scripts/upload-to-r2.js ./dist/static /static-assets`

<details>
<summary>üì¶ **CI/CD Integration**: See <code>.github/workflows/upload-assets.yml</code></summary>

This GitHub Actions workflow demonstrates how `upload-to-r2.js` can be integrated into your deployment pipeline.

```yaml
# .github/workflows/upload-assets.yml
name: Upload Assets to R2

on:
  push:
    branches:
      - main
    paths:
      - 'static/**' # Trigger when files in 'static' directory change

jobs:
  upload:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Set up Node.js
        uses: actions/setup-node@v3
        with:
          node-version: '18'

      - name: Install dependencies
        run: npm install # if scripts/upload-to-r2.js has deps

      - name: Upload static assets to R2
        run: node scripts/upload-to-r2.js ./static /public-assets
        env:
          R2_ACCOUNT_ID: ${{ secrets.R2_ACCOUNT_ID }}
          R2_ACCESS_KEY_ID: ${{ secrets.R2_ACCESS_KEY_ID }}
          R2_SECRET_ACCESS_KEY: ${{ secrets.R2_SECRET_ACCESS_KEY }}
          R2_BUCKET_NAME: ${{ secrets.R2_BUCKET_NAME }}
```

This workflow ensures that whenever static assets in the `static/` directory are pushed to `main`, they are automatically uploaded to R2 under the `/public-assets` prefix.
</details>

### Cloudflare Worker for Edge Caching & Routing

The `cloudflare-worker/cdn-worker.js` is central to the CDN's performance. It sits at the edge and can dramatically reduce latency and origin load.

```mermaid
graph TD
    A[Client Request: cdn.example.com/images/asset.jpg] --> B(Cloudflare Worker)

    subgraph Worker Logic
        B -- Check Cache --> C{Asset in Worker Cache?}
        C -- Yes --> D[Serve from Cache]
        C -- No --> E{Is it an Imgproxy Request (e.g., /img)?}
        E -- Yes --> F[Forward to Imgproxy (via Traefik)]
        E -- No --> G[Forward to Go Media (via Traefik)]
    end

    D --> A
    F -- Get Transformed Image --> B
    G -- Get Original Image --> B

    style A fill:#e0f2f7,stroke:#333,stroke-width:2px
    style B fill:#d0e6f7,stroke:#333,stroke-width:2px
    style C fill:#ffffd0,stroke:#333,stroke-width:2px
    style D fill:#e0ffd0,stroke:#333,stroke-width:2px
    style E fill:#ffffd0,stroke:#333,stroke-width:2px
    style F fill:#ffe0d0,stroke:#333,stroke-width:2px
    style G fill:#ffd0d0,stroke:#333,stroke-width:2px
```

The worker script acts as a proxy:
-   It tries to serve content directly from its edge cache.
-   If a cache miss occurs, it intelligently decides whether to fetch the asset from `imgproxy` (if it's an image transformation request) or `go-media` (for raw assets).
-   It can also handle redirects, enforce security headers, and implement A/B testing or other custom logic.

<details>
<summary>Worker Code Snippet: Basic Caching and R2 Interaction</summary>

```javascript
// cloudflare-worker/cdn-worker.js (simplified)
addEventListener('fetch', event => {
  event.respondWith(handleRequest(event.request))
})

async function handleRequest(request) {
  const url = new URL(request.url)
  const cacheKey = new Request(url.toString(), request) // Create a cache key

  // Check Cloudflare's cache first
  const cache = caches.default
  let response = await cache.match(cacheKey)

  if (response) {
    console.log('Cache hit for:', url.pathname);
    return response
  }

  console.log('Cache miss for:', url.pathname);

  // If not in cache, fetch from R2 (or your origin, e.g., go-media/imgproxy)
  // For simplicity, this worker directly fetches from R2.
  // In a real scenario, it might fetch from your Traefik-managed origin.
  try {
    // R2_BUCKET is the binding name from wrangler.toml
    const object = await R2_BUCKET.get(url.pathname.substring(1)) // Remove leading slash

    if (object === null) {
      return new Response('Asset Not Found', { status: 404 })
    }

    const headers = new Headers()
    object.writeHttpMetadata(headers)
    headers.set('etag', object.httpEtag)

    // Set caching headers for the browser and Cloudflare's edge
    headers.set('Cache-Control', 'public, max-age=31536000, immutable'); // Cache for 1 year
    
    // Convert R2 object to Response
    response = new Response(object.body, {
      headers,
      status: 200,
    })

    // Store the response in cache
    event.waitUntil(cache.put(cacheKey, response.clone()))

    return response

  } catch (e) {
    console.error('Error fetching from R2:', e);
    return new Response('Error fetching asset', { status: 500 })
  }
}
```
This worker demonstrates direct R2 access. For complex setups involving `go-media` and `imgproxy` behind Traefik, the worker would instead construct new requests to your API endpoint (e.g., `api.yourdomain.com/v1/media/KEY` or `cdn.yourdomain.com/img/...`) and proxy those responses.
</details>

[‚¨ÜÔ∏è Back to Top](#-table-of-contents)

---

## üöß Limitations, Known Issues & Future Roadmap

Every system has its boundaries and areas for growth. Here's what to keep in mind for this CDN infrastructure.

### Current Limitations

-   **Limited Admin UI for Asset Management**: Currently, asset management (upload, deletion, listing) is primarily API-driven. There is no dedicated graphical user interface for non-technical users.
-   **No Built-in Rate Limiting for Origin**: While Traefik offers rate-limiting middleware, it's not pre-configured for specific API endpoints in this setup, relying on Cloudflare's edge protection by default.
-   **Basic Signed URL Implementation**: The current signed URL implementation is for `GetObject` only. More granular control (e.g., for `PutObject` or specific headers) would require custom extensions.
-   **Static `imgproxy` Configuration**: `imgproxy` is configured via environment variables. Dynamic configuration changes require service restarts.
-   **No Real-time Analytics Dashboard**: While Cloudflare provides basic analytics for Workers and R2, a unified dashboard for CDN performance, costs, and content insights is not included.

### Known Issues

-   **Certificate Provisioning Delays**: Occasionally, Traefik's ACME challenge with Cloudflare might experience delays during initial setup or domain changes. Ensure DNS records are propagated and correctly proxied by Cloudflare.
-   **Imgproxy Cache Invalidation**: If a source image in R2 is updated but its key remains the same, `imgproxy`'s internal cache might not immediately reflect the changes. Clearing Cloudflare Worker cache or restarting `imgproxy` might be necessary.
-   **Worker/Origin Redundancy**: The Cloudflare Worker directly fetching from R2 provides high availability for retrieval. However, API-driven uploads (`go-media`) rely on the single `go-media` instance (though Docker orchestration helps with restarts).

### Future Roadmap

We envision several enhancements to make this CDN even more powerful and user-friendly:

-   **Advanced Asset Management Dashboard**: Develop a web-based UI for uploading, viewing, searching, and managing assets, including metadata editing and versioning.
-   **Video Streaming Optimization**: Add support for adaptive bitrate streaming (HLS/DASH) for video content, potentially integrating with a specialized media server or Cloudflare Stream.
-   **Granular Access Control**: Implement more sophisticated authorization mechanisms for API endpoints and asset access, integrating with a user management system.
-   **Webhooks for Asset Events**: Introduce webhooks to notify external systems upon asset upload, deletion, or transformation completion.
-   **Multi-Region R2 Replication**: Explore R2's upcoming replication features for enhanced data redundancy and geographic proximity.
-   **Performance Monitoring & Alerting**: Integrate with Prometheus/Grafana or similar tools for detailed performance metrics, logs, and alerts.
-   **Terraform/Infrastructure as Code**: Provide Terraform configurations for deploying Cloudflare resources (R2, Workers, DNS) and potentially the entire Docker Compose setup to a cloud VM.

<details>
<summary>üí° **Feature Requests?** Open an Issue!</summary>
If you have a feature idea or encounter a problem, please don't hesitate to [open an issue](https://github.com/WomB0ComB0/cdn/issues) on GitHub. We welcome contributions and feedback!
</details>

[‚¨ÜÔ∏è Back to Top](#-table-of-contents)

---

## ü§ù Contributing & Development Guidelines

We welcome contributions to make this CDN infrastructure even better! Whether it's bug fixes, new features, or improvements to documentation, your help is appreciated.

### How to Contribute

1.  **Fork the Repository**: Start by forking the `WomB0ComB0/cdn` repository to your GitHub account.
2.  **Clone Your Fork**:
    ```bash
    git clone https://github.com/YOUR_USERNAME/cdn.git
    cd cdn
    ```
3.  **Create a New Branch**:
    Choose a descriptive name for your branch (e.g., `feature/add-image-watermarking`, `fix/worker-cache-bug`, `docs/improve-installation-guide`).
    ```bash
    git checkout -b feature/your-feature-name
    ```
4.  **Make Your Changes**: Implement your feature or bug fix.
5.  **Test Your Changes**: Ensure your changes work as expected and don't introduce regressions.
6.  **Commit Your Changes**: Write clear, concise commit messages.
    ```bash
    git commit -m "feat: Briefly describe your feature or fix"
    ```
7.  **Push to Your Fork**:
    ```bash
    git push origin feature/your-feature-name
    ```
8.  **Create a Pull Request**:
    -   Go to the original `WomB0ComB0/cdn` repository on GitHub.
    -   You should see a prompt to create a new Pull Request from your pushed branch.
    -   Provide a detailed description of your changes, including why they are needed and how they were tested.

### Development Setup

To facilitate development, ensure you have the [Prerequisites](#prerequisites) installed.
For specific services:

-   **Go Media Service (`services/go-media`)**:
    -   Install [Go](https://golang.org/doc/install) (1.21+).
    -   Dependencies: `go mod tidy`.
    -   Run locally: `go run main.go` (ensure environment variables are set).

-   **Node Core Service (`services/node-core`)**:
    -   Install [Node.js](https://nodejs.org/en/download/) (18+).
    -   Dependencies: `npm install`.
    -   Run locally: `npm start` or `node index.js` (ensure environment variables are set).

-   **Cloudflare Worker (`cloudflare-worker`)**:
    -   Install `wrangler` CLI: `npm install -g wrangler`.
    -   Run locally with `wrangler dev` for quick testing.

-   **Scripts (`scripts`)**:
    -   Install Node.js (18+).
    -   Run with `node scripts/your-script.js`.

### Branching & Pull Request Guidelines

-   **`main` Branch**: This branch reflects the latest stable release. All pull requests should be merged into `main`.
-   **Feature Branches**: Use descriptive names like `feat/new-endpoint` or `refactor/r2-client`.
-   **Bugfix Branches**: Use names like `fix/auth-issue` or `bug/image-resize-error`.
-   **Commit Messages**: Follow [Conventional Commits](https://www.conventionalcommits.org/en/v1.0.0/) for clear history (e.g., `feat: add signed url generation`, `fix: correct etag handling`).
-   **Pull Request Description**: Clearly describe the problem your PR solves, how it solves it, and any potential side effects. Link to relevant issues if applicable.
-   **Code Review**: All PRs require at least one approval before merging.

### Code Style & Linting

-   **Go**:
    -   Use `go fmt` to format your code: `go fmt ./...`.
    -   Use `golangci-lint` for linting (install if not present).

-   **JavaScript/Node.js/Cloudflare Worker**:
    -   Use `ESLint` with a common configuration (e.g., Airbnb style guide). Ensure `npm install` brings in the necessary `eslint` packages.
    -   Run `eslint .` in the respective service directories.

-   **Markdown**:
    -   Keep line lengths reasonable.
    -   Use consistent heading levels and list formatting.

### Testing

-   **Unit Tests**: Write unit tests for individual functions and components.
    -   **Go**: `go test ./...` in the `services/go-media` directory.
    -   **Node.js**: Use a framework like Jest or Mocha (`npm test` in `services/node-core`).
    -   **Cloudflare Worker**: Use `wrangler test` or a testing library like `miniflare`.

-   **Integration Tests**: Test the interaction between different services (e.g., `go-media` uploading to R2, `imgproxy` fetching from R2).
    -   These can be automated as part of a CI pipeline using `docker compose up` for the test environment.

[‚¨ÜÔ∏è Back to Top](#-table-of-contents)

---

## üìÑ License, Credits & Contact

### License

This project is licensed under the **MIT License**. You are free to use, modify, and distribute this software, provided the original copyright and license notice are included.

See the [LICENSE](LICENSE) file for more details.

### Acknowledgements

This project makes extensive use of and builds upon the work of many open-source projects and cloud services:

-   **Cloudflare**: For R2 Storage, Workers, and DNS services that form the backbone of this CDN.
-   **Traefik**: As the powerful and dynamic API Gateway.
-   **Go Language**: For its performance and concurrency features in the media service.
-   **Node.js**: For the core service and utility scripts.
-   **imgproxy**: For robust and efficient on-the-fly image transformations.
-   **Hasura GraphQL Engine**: For providing a real-time GraphQL API.
-   **Docker & Docker Compose**: For containerization and orchestration.
-   **AWS SDK for Go**: For interacting with S3-compatible storage like Cloudflare R2.
-   **All open-source contributors** to the above projects and the wider developer community.

### Maintainer & Contact

This project is maintained by Mike Odnis.

-   **GitHub**: [WomB0ComB0](https://github.com/WomB0ComB0)
-   **Website**: [https://mikeodnis.dev](https://mikeodnis.dev)

For questions, issues, or collaborations, please open an issue on the GitHub repository or reach out via my website.

[‚¨ÜÔ∏è Back to Top](#-table-of-contents)

---

## üìö Appendix

This section provides additional useful information, including a changelog, frequently asked questions, troubleshooting tips, and links to API references.

### Changelog

**v1.0.0 - Initial Release (YYYY-MM-DD)**
-   Core CDN infrastructure with Traefik, Go Media, Cloudflare R2, and Worker.
-   Imgproxy integration for on-the-fly image transformations.
-   Basic asset upload and retrieval API.
-   Signed URL generation for secure access.
-   Docker Compose for local development and deployment.
-   Initial GitHub Actions workflows for CI/CD.
-   Comprehensive README documentation.

### FAQ

<details>
<summary>‚ùì **Q: How does this CDN compare to AWS CloudFront or other managed CDNs?**</summary>
‚úÖ **A:** This solution offers significant cost advantages, particularly with Cloudflare R2's zero egress fees, which can be substantial for high-traffic content. It provides a self-hosted, highly customizable origin (`go-media`, `imgproxy`) while leveraging Cloudflare's global edge network for caching. Managed CDNs offer more out-of-the-box features but often come with higher costs and less flexibility at the origin layer. This setup offers a balance of control, performance, and cost-efficiency.
</details>

<details>
<summary>‚ùì **Q: Can I use a different object storage than Cloudflare R2?**</summary>
‚úÖ **A:** The `go-media` service and `imgproxy` are built to be S3-compatible. While they are configured for R2, you could theoretically adapt them to work with AWS S3, Google Cloud Storage, or other S3-compatible providers by adjusting environment variables and possibly the AWS SDK configuration. However, R2's zero egress fees are a key differentiator.
</details>

<details>
<summary>‚ùì **Q: How do I manage cache invalidation?**</summary>
‚úÖ **A:**
1.  **Cloudflare Worker**: The worker automatically respects standard HTTP caching headers (e.g., `Cache-Control`). If you update an asset in R2 with the *same key*, you might need to manually purge the cache for that URL via the Cloudflare dashboard or API.
2.  **Versioning**: A common strategy is to include a version hash in your asset URLs (e.g., `/images/logo.{hash}.png`). When the asset changes, its URL changes, effectively creating a new cache entry and bypassing old caches. The `generate-asset-manifest.js` script can help with this.
</details>

<details>
<summary>‚ùì **Q: Is the Traefik dashboard secure?**</summary>
‚ö†Ô∏è **A:** By default, the Traefik dashboard is exposed on port `8080` and protected by basic authentication (`TRAEFIK_DASHBOARD_AUTH`). For production, it's highly recommended to:
1.  Use a strong, unique username and password.
2.  Restrict access to specific IP addresses using Traefik's IPWhitelisting middleware.
3.  Consider disabling the dashboard entirely if not actively monitored.
</details>

<details>
<summary>‚ùì **Q: How can I debug the Cloudflare Worker?**</summary>
‚úÖ **A:** You can use `wrangler dev` in the `cloudflare-worker` directory to run the worker locally with live reloading and integrated logging. Cloudflare's dashboard also provides real-time logs and tracing for deployed Workers.
</details>

### Troubleshooting

<details>
<summary>üêõ **Issue**: Services not starting with `docker compose up`</summary>
**Solution**:
-   Check Docker logs for individual containers: `docker compose logs <service_name>`.
-   Verify all environment variables in `.env` are correctly set and present.
-   Ensure Docker daemon is running and has enough resources.
-   Check for port conflicts: another process might be using ports 80, 443, or 8080.
</details>

<details>
<summary>üêõ **Issue**: Traefik dashboard or API endpoints are unreachable, or SSL errors</summary>
**Solution**:
-   **DNS & SSL**:
    -   Verify your domain's DNS records are correctly pointing to Cloudflare and are proxied (orange cloud icon).
    -   Check Traefik logs (`docker compose logs cdn-traefik`) for ACME challenge errors related to certificate provisioning. Ensure `CLOUDFLARE_EMAIL` and `CLOUDFLARE_API_KEY` are correct.
    -   Ensure your `Host()` rules in `docker-compose.yml` match your actual domain.
-   **Traefik Labels**: Double-check Traefik labels in `docker-compose.yml` for typos or incorrect routing rules.
-   **Firewall**: Ensure your server's firewall allows inbound traffic on ports 80 and 443.
</details>

<details>
<summary>üêõ **Issue**: `imgproxy` fails to fetch source images from R2</summary>
**Solution**:
-   Verify `IMGPROXY_USE_S3=true`, `IMGPROXY_S3_ENDPOINT`, `AWS_ACCESS_KEY_ID`, `AWS_SECRET_ACCESS_KEY`, and `IMGPROXY_ALLOWED_SOURCES` are correctly configured in `.env`.
-   Ensure the R2 bucket name in `IMGPROXY_ALLOWED_SOURCES` is correct.
-   Check `imgproxy` logs (`docker compose logs cdn-imgproxy`) for specific errors during image fetching.
-   Confirm the R2 access key has `s3:GetObject` permissions for the specified bucket.
</details>

<details>
<summary>üêõ **Issue**: Cloudflare Worker not deployed or not working</summary>
**Solution**:
-   Ensure `wrangler deploy` completed successfully without errors.
-   Verify `wrangler.toml` has the correct `r2_buckets` binding and `bucket_name`.
-   Check Cloudflare's dashboard under "Workers & Pages" -> "Overview" to see if your worker is active and if there are any runtime errors in its logs.
-   Confirm your domain's DNS is configured to route traffic through the Worker (e.g., CNAME `cdn.yourdomain.com` to `your-worker.your-username.workers.dev` or a custom domain setup).
</details>

### API Reference

A detailed API specification for the `go-media` service is available in OpenAPI format.

-   **OpenAPI Specification**: [openapi.yaml](openapi.yaml)

You can use tools like Swagger UI or Postman to import this file and interact with the API.

[‚¨ÜÔ∏è Back to Top](#-table-of-contents)